name: TikTok NBA Script Generator

on:
  workflow_dispatch: # Allows manual triggering
  schedule:
    - cron: '0 12 * * *'  # Run daily at 12 PM UTC

permissions:
  contents: write

jobs:
  generate-tiktok-script:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
    
    - name: Install dependencies
      run: pip install requests beautifulsoup4 edge-tts nest_asyncio pillow openai
    
    - name: Create source directory and clean old files
      run: |
        mkdir -p source
        echo "Checking for existing files to replace..."
        if [ -f "source/headline.txt" ]; then
          echo "Removing existing headline.txt"
          rm "source/headline.txt"
        fi
        if [ -f "source/script.txt" ]; then
          echo "Removing existing script.txt"
          rm "source/script.txt"
        fi
        if [ -f "source/image.jpg" ]; then
          echo "Removing existing image.jpg"
          rm "source/image.jpg"
        fi
        if [ -f "source/voiceover.mp3" ]; then
          echo "Removing existing voiceover.mp3"
          rm "source/voiceover.mp3"
        fi
        echo "Ready to generate new files..."
    
    - name: Generate TikTok Script and files
      run: |
        python3 - <<EOF
        import requests
        from bs4 import BeautifulSoup
        import json
        import asyncio
        import edge_tts
        import nest_asyncio
        from PIL import Image
        import io
        import os
        import time
        import random
        import urllib.parse

        # Allow async in some environments
        nest_asyncio.apply()

        # Scraper for NBA article
        def scrape_nba_news(url):
            headers = {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
            }
            try:
                response = requests.get(url, headers=headers, timeout=10)
                response.raise_for_status()
                soup = BeautifulSoup(response.text, 'html.parser')

                # Headline
                h1 = soup.find('header', class_='entry-header')
                headline = h1.find('h1').get_text(strip=True) if h1 else 'No headline found'

                # Article content
                content_div = soup.find('div', class_='entry-content')
                article_text = content_div.get_text(separator=' ', strip=True) if content_div else 'No content found'

                # Image URL
                og_image = soup.find('meta', property='og:image')
                img_url = og_image['content'] if og_image and og_image.has_attr('content') else 'No image found'

                return headline, article_text, img_url
            except Exception as e:
                print(f'Error scraping: {e}')
                return None, None, None

        # AI generation using correct Pollinations API endpoints
        def generate_tiktok_script(headline, article_content):
            prompt = f"""You are writing a TikTok NBA commentary script for a text-to-speech voice.

        CRITICAL TTS RULES for perfect natural speech:
        - Write like you are having an excited conversation with a friend
        - Add commas when you would naturally take a breath while speaking
        - Use commas to separate different thoughts or topics
        - Add commas after team names when transitioning to what they did
        - Put commas before "but", "and", "so" when connecting major ideas
        - Do not overdo it - aim for 2-4 word groups between most commas
        - NO periods, colons, dashes, or any punctuation except commas and ONE period at the very end
        - Instead of "grade: B" say "I give them a B" or "that is a solid B grade"
        - NO symbols like colons, dashes, hyphens - only words and commas
        - Sound enthusiastic and natural, not robotic or rushed
        - Be under 60 seconds when spoken

        NBA Headline: {headline}
        Article Info: {article_content[:800]}

        Write with natural speech rhythm and spell out grades naturally. NO colons, dashes, or symbols - just words and commas. Output just the script."""

            # URL encode the prompt for GET request
            import urllib.parse
            encoded_prompt = urllib.parse.quote(prompt)

            # Try multiple API methods according to the cheatsheet
            methods_to_try = [
                {
                    'name': 'GET Text Generation',
                    'method': 'GET',
                    'url': f'https://text.pollinations.ai/{encoded_prompt}',
                    'headers': {'User-Agent': 'Mozilla/5.0 (compatible; TikTokBot/1.0)'}
                },
                {
                    'name': 'POST Text Generation',
                    'method': 'POST',
                    'url': 'https://text.pollinations.ai/',
                    'headers': {
                        'Content-Type': 'application/json',
                        'User-Agent': 'Mozilla/5.0 (compatible; TikTokBot/1.0)'
                    },
                    'data': {'prompt': prompt}
                },
                {
                    'name': 'OpenAI Compatible',
                    'method': 'POST',
                    'url': 'https://text.pollinations.ai/openai',
                    'headers': {
                        'Content-Type': 'application/json',
                        'User-Agent': 'Mozilla/5.0 (compatible; TikTokBot/1.0)'
                    },
                    'data': {
                        'model': 'gpt-3.5-turbo',
                        'messages': [{'role': 'user', 'content': prompt}],
                        'max_tokens': 350,
                        'temperature': 0.8
                    }
                }
            ]

            for method in methods_to_try:
                try:
                    print(f"Trying {method['name']}...")
                    
                    # Add delay to avoid rate limiting
                    time.sleep(random.uniform(2, 4))
                    
                    if method['method'] == 'GET':
                        response = requests.get(
                            method['url'],
                            headers=method['headers'],
                            timeout=30
                        )
                    else:
                        response = requests.post(
                            method['url'],
                            headers=method['headers'],
                            json=method['data'],
                            timeout=30
                        )
                    
                    print(f"Response status: {response.status_code}")
                    print(f"Response headers: {dict(response.headers)}")
                    
                    if response.status_code == 200:
                        # For GET requests, response might be plain text
                        if method['method'] == 'GET':
                            content = response.text.strip()
                            if content and len(content) > 50:  # Basic validation
                                return content
                            else:
                                print(f"GET response too short: {content[:100]}")
                                continue
                        
                        # For POST requests, try to parse JSON
                        else:
                            try:
                                result = response.json()
                                print(f"JSON keys: {list(result.keys()) if isinstance(result, dict) else 'Not a dict'}")
                                
                                # Handle OpenAI format
                                if 'choices' in result and len(result['choices']) > 0:
                                    content = result['choices'][0]['message']['content']
                                    return content.strip()
                                # Handle other formats
                                elif 'text' in result:
                                    return result['text'].strip()
                                elif 'response' in result:
                                    return result['response'].strip()
                                # If it's a string directly
                                elif isinstance(result, str):
                                    return result.strip()
                                else:
                                    print(f"Unexpected JSON structure: {result}")
                                    continue
                                    
                            except json.JSONDecodeError:
                                # Maybe it's plain text
                                content = response.text.strip()
                                if content and len(content) > 50:
                                    return content
                                else:
                                    print(f"Invalid JSON and short text: {response.text[:100]}")
                                    continue
                    else:
                        print(f"HTTP {response.status_code}: {response.text[:200]}")
                        continue
                        
                except requests.exceptions.RequestException as e:
                    print(f"Request error with {method['name']}: {e}")
                    continue
                except Exception as e:
                    print(f"Unexpected error with {method['name']}: {e}")
                    continue

            # If all methods fail, generate a fallback script
            print("All API methods failed, generating fallback script...")
            clean_headline = headline.replace(':', ' -').replace(';', ',')
            fallback_script = f"""Hey NBA fans, let me break down this crazy news for you, {clean_headline}, this is absolutely wild, the implications for the league are huge, teams are making moves and players are switching up, what do you think about this situation, drop your thoughts in the comments below."""
            
            return fallback_script

        # Download and save image
        def download_image(img_url, output_path):
            try:
                if img_url == 'No image found':
                    return False
                
                headers = {
                    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
                }
                response = requests.get(img_url, headers=headers, timeout=15)
                response.raise_for_status()
                
                # Open and save image as JPG
                image = Image.open(io.BytesIO(response.content))
                # Convert to RGB if necessary (for JPG format)
                if image.mode in ('RGBA', 'P'):
                    image = image.convert('RGB')
                image.save(output_path, 'JPEG', quality=90)
                return True
            except Exception as e:
                print(f'Error downloading image: {e}')
                return False

        # Save to MP3 with Edge TTS
        async def save_script_to_voice(script_text, voice='en-US-GuyNeural', output_path='source/voiceover.mp3'):
            try:
                communicate = edge_tts.Communicate(script_text, voice)
                await communicate.save(output_path)
                return True
            except Exception as e:
                print(f'Error generating TTS: {e}')
                return False

        # Main function
        async def main():
            url = 'https://www.basketballinsiders.org/news/warriors-cavaliers-mavericks-expected-to-pursue-lebron-james-in-2026/'
            print(f"Scraping URL: {url}")
            
            headline, article_content, img_url = scrape_nba_news(url)

            if not headline:
                print('‚ùå Failed to scrape article.')
                return

            print(f'üì∞ Headline: {headline}')
            print()

            script = generate_tiktok_script(headline, article_content)
            print('üé¨ TTS-Friendly TikTok Voiceover Script:')
            print()
            print(script)
            print()
            print(f'üñºÔ∏è Image URL: {img_url}')

            # Save headline to file
            with open('source/headline.txt', 'w', encoding='utf-8') as f:
                f.write(headline)
            print('‚úÖ Headline saved to source/headline.txt')

            # Save generated script to file
            with open('source/script.txt', 'w', encoding='utf-8') as f:
                f.write(script)
            print('‚úÖ Script saved to source/script.txt')

            # Download and save image
            image_saved = download_image(img_url, 'source/image.jpg')
            if image_saved:
                print('‚úÖ Image saved to source/image.jpg')
            else:
                print('‚ö†Ô∏è Image could not be saved')

            # Generate TTS voiceover
            print()
            print('üîä Generating voiceover MP3 with Edge TTS...')
            tts_success = await save_script_to_voice(script, voice='en-US-GuyNeural', output_path='source/voiceover.mp3')
            if tts_success:
                print('‚úÖ Voiceover saved to source/voiceover.mp3')
            else:
                print('‚ö†Ô∏è TTS generation failed')

        # Run script
        asyncio.run(main())
        EOF

    - name: Set up Git identity
      run: |
        git config --global user.name "cowboycode9"
        git config --global user.email "cowboycode9@outlook.com"

    - name: Commit and push generated files
      env:
        GH_PAT: ${{ secrets.GH_PAT }}
      run: |
        git stash --include-untracked
        git pull origin main --rebase || echo "Warning: rebase skipped"
        git stash pop || true

        git add source/
        timestamp=$(TZ="UTC" date +"%Y-%m-%d %H:%M:%S UTC")
        git commit -m "Generated TikTok NBA script and assets: ${timestamp}" || echo "No changes to commit"
        git push https://x-access-token:${GH_PAT}@github.com/${{ github.repository }}.git HEAD:main
