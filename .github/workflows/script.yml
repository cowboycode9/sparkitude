name: TikTok NBA Script Generator

on:
  workflow_dispatch: # Allows manual triggering
  schedule:
    - cron: '0 12 * * *'  # Run daily at 12 PM UTC

permissions:
  contents: write

jobs:
  generate-tiktok-script:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v3
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.10'
    
    - name: Install dependencies
      run: pip install requests beautifulsoup4 edge-tts nest_asyncio pillow
    
    - name: Create source directory and clean old files
      run: |
        mkdir -p source
        echo "Checking for existing files to replace..."
        if [ -f "source/headline.txt" ]; then
          echo "Removing existing headline.txt"
          rm "source/headline.txt"
        fi
        if [ -f "source/script.txt" ]; then
          echo "Removing existing script.txt"
          rm "source/script.txt"
        fi
        if [ -f "source/image.jpg" ]; then
          echo "Removing existing image.jpg"
          rm "source/image.jpg"
        fi
        if [ -f "source/voiceover.mp3" ]; then
          echo "Removing existing voiceover.mp3"
          rm "source/voiceover.mp3"
        fi
        echo "Ready to generate new files..."
    
    - name: Generate TikTok Script and files
      run: |
        python3 - <<EOF
        import requests
        from bs4 import BeautifulSoup
        import json
        import asyncio
        import edge_tts
        import nest_asyncio
        from PIL import Image
        import io
        import os
        import time
        import random
        import urllib.parse

        # Allow async in some environments
        nest_asyncio.apply()

        # Scraper for NBA article
        def scrape_nba_news(url):
            headers = {'User-Agent': 'Mozilla/5.0'}
            try:
                response = requests.get(url, headers=headers)
                soup = BeautifulSoup(response.text, 'html.parser')

                # Headline
                h1 = soup.find('header', class_='entry-header')
                headline = h1.find('h1').get_text(strip=True) if h1 else 'No headline found'

                # Article content
                content_div = soup.find('div', class_='entry-content')
                article_text = content_div.get_text(separator=' ', strip=True) if content_div else 'No content found'

                # Image URL
                og_image = soup.find('meta', property='og:image')
                img_url = og_image['content'] if og_image and og_image.has_attr('content') else 'No image found'

                return headline, article_text, img_url
            except Exception:
                return None, None, None

        # AI generation using correct Pollinations API endpoints
        def generate_tiktok_script(headline, article_content):
            prompt = f"""You are writing a TikTok NBA commentary script for a text-to-speech voice that sounds NATURAL and HUMAN.

        CRITICAL TTS RULES for natural human speech with SHORT PAUSES:
        - Use commas strategically for natural breathing and emphasis (short pauses)
        - NEVER use periods except ONE at the very end (periods create long pauses)
        - Break up long thoughts where humans naturally pause when excited
        - Think about how YOU would tell this story to a friend face-to-face
        - Use commas after impactful statements or when switching topics
        - Create natural rhythm with commas: "Statement, quick reaction, another statement, emphasis"
        - Vary the length between commas naturally - sometimes 2-3 words, sometimes 5-7 words
        - Sound conversational and excited, not like reading a script
        - Keep it under 60 seconds when spoken

        GOOD EXAMPLE of natural rhythm with SHORT pauses:
        "Yo the Lakers just made a crazy move, they traded for this All-Star guard, I'm honestly shocked by this, the fit is perfect though, this could be championship level stuff, what do you guys think about this trade"

        BAD EXAMPLE (too long without breaks):
        "Yo the Lakers just made a crazy move and they traded for this All-Star guard and I'm honestly shocked by this but the fit is perfect though and this could be championship level stuff so what do you guys think about this trade"

        NBA Headline: {headline}
        Article Info: {article_content[:800]}

        Write like you're having an excited conversation with natural SHORT pauses using commas. Think where you'd naturally breathe while speaking fast and excited. Output just the script with ONE period at the end only."""

            # URL encode the prompt for GET request
            import urllib.parse
            encoded_prompt = urllib.parse.quote(prompt)

            # Try multiple API methods according to the cheatsheet
            methods_to_try = [
                {
                    'name': 'GET Text Generation',
                    'method': 'GET',
                    'url': f'https://text.pollinations.ai/{encoded_prompt}',
                    'headers': {'User-Agent': 'Mozilla/5.0 (compatible; TikTokBot/1.0)'}
                },
                {
                    'name': 'POST Text Generation',
                    'method': 'POST',
                    'url': 'https://text.pollinations.ai/',
                    'headers': {
                        'Content-Type': 'application/json',
                        'User-Agent': 'Mozilla/5.0 (compatible; TikTokBot/1.0)'
                    },
                    'data': {'prompt': prompt}
                },
                {
                    'name': 'OpenAI Compatible',
                    'method': 'POST',
                    'url': 'https://text.pollinations.ai/openai',
                    'headers': {
                        'Content-Type': 'application/json',
                        'User-Agent': 'Mozilla/5.0 (compatible; TikTokBot/1.0)'
                    },
                    'data': {
                        'model': 'gpt-3.5-turbo',
                        'messages': [{'role': 'user', 'content': prompt}],
                        'max_tokens': 350,
                        'temperature': 0.8
                    }
                }
            ]

            for method in methods_to_try:
                try:
                    print(f"Trying {method['name']}...")
                    
                    # Add delay to avoid rate limiting
                    time.sleep(random.uniform(2, 4))
                    
                    if method['method'] == 'GET':
                        response = requests.get(
                            method['url'],
                            headers=method['headers'],
                            timeout=30
                        )
                    else:
                        response = requests.post(
                            method['url'],
                            headers=method['headers'],
                            json=method['data'],
                            timeout=30
                        )
                    
                    print(f"Response status: {response.status_code}")
                    print(f"Response headers: {dict(response.headers)}")
                    
                    if response.status_code == 200:
                        # For GET requests, response might be plain text
                        if method['method'] == 'GET':
                            content = response.text.strip()
                            if content and len(content) > 50:  # Basic validation
                                return content
                            else:
                                print(f"GET response too short: {content[:100]}")
                                continue
                        
                        # For POST requests, try to parse JSON
                        else:
                            try:
                                result = response.json()
                                print(f"JSON keys: {list(result.keys()) if isinstance(result, dict) else 'Not a dict'}")
                                
                                # Handle OpenAI format
                                if 'choices' in result and len(result['choices']) > 0:
                                    content = result['choices'][0]['message']['content']
                                    return content.strip()
                                # Handle other formats
                                elif 'text' in result:
                                    return result['text'].strip()
                                elif 'response' in result:
                                    return result['response'].strip()
                                # If it's a string directly
                                elif isinstance(result, str):
                                    return result.strip()
                                else:
                                    print(f"Unexpected JSON structure: {result}")
                                    continue
                                    
                            except json.JSONDecodeError:
                                # Maybe it's plain text
                                content = response.text.strip()
                                if content and len(content) > 50:
                                    return content
                                else:
                                    print(f"Invalid JSON and short text: {response.text[:100]}")
                                    continue
                    else:
                        print(f"HTTP {response.status_code}: {response.text[:200]}")
                        continue
                        
                except requests.exceptions.RequestException as e:
                    print(f"Request error with {method['name']}: {e}")
                    continue
                except Exception as e:
                    print(f"Unexpected error with {method['name']}: {e}")
                    continue

            # If all methods fail, generate a fallback script
            print("All API methods failed, generating fallback script...")
            clean_headline = headline.replace(':', ' -').replace(';', ',')
            fallback_script = f"""Hey NBA fans, let me break down this crazy news for you, {clean_headline}, this is absolutely wild, the implications for the league are huge, teams are making moves and players are switching up, what do you think about this situation, drop your thoughts in the comments below."""
            
            return fallback_script

        # Download and save image
        def download_image(img_url, output_path):
            try:
                if img_url == 'No image found':
                    return False
                
                headers = {'User-Agent': 'Mozilla/5.0'}
                response = requests.get(img_url, headers=headers)
                response.raise_for_status()
                
                # Open and save image as JPG
                image = Image.open(io.BytesIO(response.content))
                # Convert to RGB if necessary (for JPG format)
                if image.mode in ('RGBA', 'P'):
                    image = image.convert('RGB')
                image.save(output_path, 'JPEG', quality=90)
                return True
            except Exception as e:
                print(f'Error downloading image: {e}')
                return False

        # Save to MP3 with Edge TTS
        async def save_script_to_voice(script_text, voice='en-US-GuyNeural', output_path='source/voiceover.mp3'):
            communicate = edge_tts.Communicate(script_text, voice)
            await communicate.save(output_path)

        # Main function
        async def main():
            url = 'https://www.basketballinsiders.org/news/warriors-cavaliers-mavericks-expected-to-pursue-lebron-james-in-2026/'
            headline, article_content, img_url = scrape_nba_news(url)

            if not headline:
                print('‚ùå Failed to scrape article.')
                return

            print(f'üì∞ Headline: {headline}')
            print()

            script = generate_tiktok_script(headline, article_content)
            print('üé¨ TTS-Friendly TikTok Voiceover Script:')
            print()
            print(script)
            print()
            print(f'üñºÔ∏è Image URL: {img_url}')

            # Save headline to file
            with open('source/headline.txt', 'w', encoding='utf-8') as f:
                f.write(headline)
            print('‚úÖ Headline saved to source/headline.txt')

            # Save generated script to file
            with open('source/script.txt', 'w', encoding='utf-8') as f:
                f.write(script)
            print('‚úÖ Script saved to source/script.txt')

            # Download and save image
            image_saved = download_image(img_url, 'source/image.jpg')
            if image_saved:
                print('‚úÖ Image saved to source/image.jpg')
            else:
                print('‚ö†Ô∏è Image could not be saved')

            # Generate TTS voiceover
            print()
            print('üîä Generating voiceover MP3 with Edge TTS...')
            await save_script_to_voice(script, voice='en-US-GuyNeural', output_path='source/voiceover.mp3')
            print('‚úÖ Voiceover saved to source/voiceover.mp3')

        # Run script
        asyncio.run(main())
        EOF

    - name: Set up Git identity
      run: |
        git config --global user.name "cowboycode9"
        git config --global user.email "cowboycode9@outlook.com"

    - name: Commit and push generated files
      env:
        GH_PAT: ${{ secrets.GH_PAT }}
      run: |
        git stash --include-untracked
        git pull origin main --rebase || echo "Warning: rebase skipped"
        git stash pop || true

        git add source/
        timestamp=$(TZ="UTC" date +"%Y-%m-%d %H:%M:%S UTC")
        git commit -m "Generated TikTok NBA script and assets: ${timestamp}" || echo "No changes to commit"
        git push https://x-access-token:${GH_PAT}@github.com/${{ github.repository }}.git HEAD:main
